use crate::{
    utils::{
        image::{
            ImageReader,
            Image
        }
    },
    graphics::{
        bindgroup,
        bindgroup::{
            bind_group_entry
        },
        texture::{
            TextureData
        },
        game::{
            model::{
                Mesh,
                Model,
                Material
            },
            vertex::{
                Vertex,
                unique_vertices_and_indices,
            },
            entity::Entity
        },
        buffer
    },
    physics::{
        body::{
            SmallPhysicalBody,
            PhysicalBody
        }
    }
};
use image::GenericImageView;
use wgpu::{
    Device,
    BufferUsages,
    Queue,
    BindGroupLayout,
    BindingResource
};

use crate::errors::{
    game::{
        TerrainGenerationError
    }
};

// this procedurla terrain has a size that's generated by the number of pixels of the image.
// if the image is a 5x5 ( 5 pixel width, 5 pixel height), the vertices will be 25, arranged in a
// 5x5 grid. 
//
// NOTE: depending on the player distance, the farthest vertices might appear as a bigger grid? 
//
use anyhow::Error;
use crate::user::Pipe;
pub struct ProceduralTerrain {
    height_map: ImageReader,
    mesh: Mesh
}

impl ProceduralTerrain {
    pub fn generate_indices(vertices: &Vec<Vertex>) -> Vec<u32> {
        let n = vertices.len() as u32;
        let mut indices: Vec<u32> = vec![];

        for i in 0..(n-2) {
            if i % 2 == 0 {
                indices.push(i);
                indices.push(i + 1);
                indices.push(i + 2);
            } else {
                indices.push(i + 2);
                indices.push(i + 1);
                indices.push(i);
            }
        }

        indices
    }
    pub fn new(device: &Device, queue: &Queue, desc: ProceduralTerrainDescriptor, texture_bgl: &BindGroupLayout) -> Result<Entity, Error> {
        
        let image_data = ImageReader::new_luma(desc.dir, desc.name)?;
        let mut vertices: Vec<Vertex> = vec![];
        let mut indices: Vec<u32> = vec![];
        println!("{:?}", image_data);
        if let ImageReader::Luma(Image {
            image: image::DynamicImage::ImageLuma8(img),
            ..
        }) = image_data {
            println!("image luma for height map found");
          // NOTE: FOR SQUARED TERRAINS ONLY
    
            let grid_size = (36 as f32).sqrt() as i32;
            println!("grid size{:?}", grid_size);
            let corrections = ((img.width() / 2) as i32, (img.height() / 2) as i32);
            for x in ((-grid_size/2)..(grid_size/2)) {
            //((-grid_size/2)..(grid_size/2)).map(|x| {
                for y in ((-grid_size/2)..(grid_size/2)) { 
                    println!("one interaction in creation of the loop");
                    //(-grid_size/2..grid_size/2).map(|y| {

                    let pixel = img.get_pixel((corrections.0 + x) as u32, (corrections.1 + y) as u32); 
                    let height = (desc.max_height - desc.min_height) * (pixel[0] as f32 / 255 as f32) + desc.min_height;
                    &mut vertices.push(Vertex{
                        position: [x as f32, height, y as f32],
                        tex_coords: [x as f32, height],
                        normal: [x as f32, height, y as f32]
                    });
                }
            }
        
        // NOTE: This algorithm should be moved inside a function as it is amazing right?
        // NOTE: Indices Generation occures here
             
        println!("i vertici del terreno{:?}", &vertices); 

        for index in 0..(vertices.len() / 2 as usize) {
            if (vertices[index].position[0] != (grid_size / 2) as f32) |
               (vertices[index].position[2] != (grid_size / 2) as f32) {
                    
                let index = index as u32;
                indices.push(index);
                indices.push(index + grid_size as u32);
                indices.push(index + grid_size as u32 + 1);

                indices.push(index);
                indices.push(index + 1);
                indices.push(index + grid_size as u32 + 1);    
            }
        }
        println!("EIIII\n Ecco la dimensione degli indici: {}", indices.len());
        //let (indices, clean_vertices) = unique_vertices_and_indices(vertices);
        //let (indices, clean_vertices) = (Self::generate_indices(&vertices), vertices);
        let clean_vertices = vertices;
        let vertex_buffer = buffer::create_buffer(
			device,
		    clean_vertices.clone(),
			BufferUsages::VERTEX
		);

        let index_buffer = buffer::create_buffer(
            &device,
            indices.clone(),
            BufferUsages::INDEX
		);
        
        let n = indices.len() as u32;
        for index in indices.iter() {
            if index > &(clean_vertices.len() as u32) {
                println!("INDICE SFORA");        
            }        
        }
        let mesh_phys = SmallPhysicalBody::new(&clean_vertices, &indices); 

        let mesh = Mesh {
            name: "Procedural Terrain".to_string(),
            vertex_buffer,
            index_buffer,
            // NOTE: i have no idea what putting 0 here is doing
            material: 0 as usize,
            num_elements: n,
            vertices: clean_vertices,
            physics: mesh_phys
        };
        
        let meshes = vec![mesh];
        let phys = PhysicalBody::new(10000., 0., &meshes);

        let mut model = Model {
            meshes: meshes,
            materials: vec![],
            physics: phys
        };

        // WE HAVE TO CREATE THE MATERIAL, made of just a single TEXTUREDATA

        let texture = TextureData::new_texture(device, queue, desc.image, Some("Procedural Terrain"));
        let view = TextureData::new_view(&texture);
        let sampler = TextureData::new_sampler(&device);
        let texture_bindgroup = bindgroup::create_bind_group(
			&device,
			texture_bgl,
			&[
				bind_group_entry!(0, BindingResource::TextureView(&view)),
				bind_group_entry!(1, BindingResource::Sampler(&sampler))
			],
			Some(" Texture bindgroup in obj loading")
		); 
 
        model.materials.push(
            Material {
                name: String::from("Terrain material"), 
                texture_data: TextureData {
                    texture,
                    view,
                    sampler,
                    bind_group: Some(texture_bindgroup),
                    bind_group_layout: None
                }
            }
        );
            Ok(Entity::new(model, None, desc.pipe))
        } else {
            anyhow::bail!(TerrainGenerationError);
        }    
    }
}
pub struct ProceduralTerrainDescriptor<'a> {
    pub dir: &'a str,
    pub name: &'a str,
    pub pipe: Pipe,
    pub max_height: f32,
    pub min_height: f32,
    pub image: ImageReader
}


